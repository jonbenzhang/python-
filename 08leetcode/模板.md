## 递归使用的模板

```python
def recursion(level,param1,param2):
    # 递归终止条件,防止进入死循环
    if level>MAX_VAL:
        return
    # 处理当前层的数据
    process(level,data)
    
    # 继续进行递归，进入下一层
    recursion(level,p1,p2)

    # 如果当前层有需要处理的数据或者其他重置操作
    # 恢复当前层的状态，像对数据的修改
```

## 分治代码模板

分治就是一种特殊的递归

```python
def devide_conquer(problem,param1,param2...):
    # 递归终止条件
    if problem is None:
        print_result
        return
    #处理数据
    data = process(problem)
    
    # 不同的数据对应不同的处理方式,(分治对于递归的特殊之处)
     subresult1 = self.divide_conquer(subproblems[0], p1, ...)   
     subresult2 = self.divide_conquer(subproblems[1], p1, ...)   
      subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
    # 收集结果，生成结果
    result = process_result(subresult1, subresult2, subresult3, …)
    # 如果当前层有需要处理的数据或者其他重置操作
    # 恢复当前层的状态，像对数据的修改
    
```

## 二分查找模板

使用二分查找需要,列表 是有序的

```python
left,right = 0,len(array)-1
while left<=right:
    mid = (left+right)//2
    if array[mid]==target:
        return mid
    elif array[mide]<target:
       left = mid +1
    else:
       right = mid-1
```

## 位运算

```python
# 判断奇偶数
x&1==1 #奇数
x&1 ==0 # 偶数
#把x的最低位置的1清零
x&(x-1) 
# 得到最低位的1
x&-x
```

布隆过滤器

```python
from bitarray import bitarray
import mmh3


class BloomFilter:
    def __init__(self, size, hash_num):
        # 存储信息的二进制串的长度
        self.size = size
        # 每一个字符在布隆过滤器中,存储的位数(有多少位需要为1)
        self.hash_num = hash_num
        # 创建二进制串行
        self.bit_array = bitarray(size)
        # 将二进制串,所有元素都置为0
        self.bit_array.setall(0)

    def add(self, s):
        for seed in range(self.hash_num):
            result = mmh3.hash(s, seed) % self.size
            self.bit_array[result] = 1

    def lookup(self, s):
        for seed in range(self.hash_num):
            result = mmh3.hash(s, seed) % self.size
            if self.bit_array[result] == 0:
                return "Nope"
            return "Probably"


bf = BloomFilter(5000, 7)
bf.add("zhang")
print(bf.lookup("zhang1"))
print(bf.lookup("zhang"))

```

LRUCache实现


```python
class LRUCache:

    def __init__(self, capacity: int):
        self.dic = OrderedDict()
        self.capatity = capacity

    def get(self, key: int) -> int:
        if key not in self.dic:
            return -1
        else:
            val = self.dic[key]
            # last为True为移动到尾部(默认为True)
            # last为False为移动到头部
            self.dic.move_to_end(key)
            return val

    def put(self, key: int, value: int) -> None:
        if key in self.dic:
            self.dic.move_to_end(key)
        else:
            if self.capatity > 0:
                self.capatity -= 1
            else:
                self.dic.popitem(last=False)
        self.dic[key] = value
```

