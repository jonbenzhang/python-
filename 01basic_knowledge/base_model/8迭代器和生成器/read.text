一. 生成器：
背景：通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
　　所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator
二.迭代器:
    任何实现了__iter__和__next__()方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，直到容器中没有更多元素时抛出StopIteration异常并停止迭代。
    实现了__iter__方法的对象就叫做可迭代对象
    区别：一个可迭代的对象必须是定义了__iter__()方法的对象；而一个迭代器必须是同时定义了__iter__()方法和next()方法的对象。



生成器与迭代器的区别
    迭代器（iterator）是一个实现了迭代器协议（__iter__和__next__()方法）的对象。
    生成器（generator）是通过yield语句或生成器函数快速生成迭代器，可以不用iter和next方法 。
    生成器本质上也是一个迭代器，自己实现了可迭代协议，与迭代器不同的是生成器的实现方式不同，可以通过生成器表达式和生成器函数两种方式实现，代码更简洁。
    生成器和迭代器都是惰性可迭代对象，只能遍历一次，数据取完抛出Stopiteration异常

凡是可作用于for循环的对象都是可迭代对象；
凡是可作用于next()函数的对象都是迭代器，它们表示一个惰性计算的序列；
集合数据类型如list、dict、str等是可迭代对象，但不是迭代器，不过可以通过iter()方法获得一个Iterator对象；
文件是可迭代对象，也是迭代器。




参考 https://blog.csdn.net/sumatch/article/details/99072268