Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。
thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，threading提供了更高级别、功能更强的线程管理的功能。
threading 模块对thread模块进行了封装
Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。
避免使用thread模块，因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading出现冲突；
其次低级别的thread模块的同步原语很少(实际上只有一个)，而threading模块则有很多；
再者，thread模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少threading模块能确保重要的子线程退出后进程才退出。
thread模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而threading模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。

threading模块
multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍（官方链接）
 
##　进程和线程的对比
 * 进程是最小的内存分配单位
 * 线程是操作系统调度的最小单位
 * 线程被cpu执行了
 * 进程中至少包含一个线程
 * 一个进程中可以开启多个线程
 * 开启一个线程所需要的时间要远远小于开启一个进程所需要的时间
 * 多个线程内部拥有自己的数据栈，数据不共享(线程中只存储支持自己运行的最少资源)
 * 全局变量在多个线程之间共享 
## 全局解释器锁GIL
* python 线程可以同时在多个cpu上运行(但是为了防止出现数据冲突,CPython进行了限制)
* CPython解释器限制，在同一时间只有一个线程在cpu上运行.
* 在平常的web程序，或爬虫中耗时最多的是高io操作．
*　只有在高计算中,GIL锁才会大大影响性能    
对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。
在多线程环境中，Python 虚拟机按以下方式执行：
1. 设置 GIL；
2. 切换到一个线程去运行；
3. 运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；
4. 把线程设置为睡眠状态；
5. 解锁 GIL；
6. 再次重复以上所有步骤。
　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。